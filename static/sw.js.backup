/**
 * Service Worker - æä¾›é›¢ç·šåŠŸèƒ½å’Œå¿«å–ç­–ç•¥
 */

const CACHE_NAME = 'ai-chat-v1.0.0';
const STATIC_CACHE = 'static-v1.0.0';
const DYNAMIC_CACHE = 'dynamic-v1.0.0';

// éœ€è¦å¿«å–çš„éœæ…‹è³‡æº
const STATIC_ASSETS = [
    '/',
    '/static/css/styles.css',
    '/static/js/app-core.js',
    '/static/js/loader.js',
    '/static/js/utils/error-handler.js',
    '/static/js/utils/performance-monitor.js',
    '/static/js/utils/api-manager.js',
    '/static/js/utils/security-config.js',
    '/static/js/utils/accessibility.js',
    '/static/js/utils/notifications.js',
    '/static/js/utils/speech.js',
    '/static/js/chat/chat-core.js',
    '/static/js/chat/chat-history.js',
    '/static/js/chat/chat-input.js',
    '/static/js/chat/chat-display.js',
    '/static/js/maps/maps-core.js',
    '/static/js/maps/maps-search.js',
    '/static/js/maps/maps-hospital.js',
    '/static/js/maps/maps-direction.js',
    '/static/js/lib/marked.min.js',
    '/static/images/bot.png',
    '/static/manifest.json'
];

// ä¸éœ€è¦å¿«å–çš„ URL æ¨¡å¼
const EXCLUDED_URLS = [
    /\/admin\//,
    /\/api\/feedback\//,
    /\/api\/messages\//,
    /\/api\/conversations\//,
    /chrome-extension:/,
    /maps\.googleapis\.com/,
    /fonts\.googleapis\.com/,
    /fonts\.gstatic\.com/,
    /cdnjs\.cloudflare\.com/
];

// å®‰è£äº‹ä»¶ - å¿«å–éœæ…‹è³‡æº
self.addEventListener('install', (event) => {
    console.log('[SW] å®‰è£ä¸­...');
    
    event.waitUntil(
        caches.open(STATIC_CACHE)
            .then((cache) => {
                console.log('[SW] å¿«å–éœæ…‹è³‡æº');
                return cache.addAll(STATIC_ASSETS);
            })
            .then(() => {
                console.log('[SW] å®‰è£å®Œæˆ');
                return self.skipWaiting();
            })
            .catch((error) => {
                console.error('[SW] å®‰è£å¤±æ•—:', error);
            })
    );
});

// å•Ÿç”¨äº‹ä»¶ - æ¸…ç†èˆŠå¿«å–
self.addEventListener('activate', (event) => {
    console.log('[SW] å•Ÿç”¨ä¸­...');
    
    event.waitUntil(
        caches.keys()
            .then((cacheNames) => {
                const deletePromises = cacheNames
                    .filter((cacheName) => {
                        return cacheName !== STATIC_CACHE && 
                               cacheName !== DYNAMIC_CACHE &&
                               cacheName !== CACHE_NAME;
                    })
                    .map((cacheName) => {
                        console.log('[SW] åˆªé™¤èˆŠå¿«å–:', cacheName);
                        return caches.delete(cacheName);
                    });
                
                return Promise.all(deletePromises);
            })
            .then(() => {
                console.log('[SW] å•Ÿç”¨å®Œæˆ');
                return self.clients.claim();
            })
    );
});

// æŠ“å–äº‹ä»¶ - å¿«å–ç­–ç•¥
self.addEventListener('fetch', (event) => {
    const { request } = event;
    const url = new URL(request.url);
    
    // è·³éä¸éœ€è¦è™•ç†çš„è«‹æ±‚
    if (shouldExcludeUrl(url)) {
        return;
    }
    
    // æ ¹æ“šè«‹æ±‚é¡å‹ä½¿ç”¨ä¸åŒç­–ç•¥
    if (request.method === 'GET') {
        if (isStaticAsset(url)) {
            // éœæ…‹è³‡æºï¼šå¿«å–å„ªå…ˆ
            event.respondWith(cacheFirst(request));
        } else if (isApiRequest(url)) {
            // API è«‹æ±‚ï¼šç¶²è·¯å„ªå…ˆ
            event.respondWith(networkFirst(request));
        } else {
            // å…¶ä»–è«‹æ±‚ï¼šå¿«å–å›é€€
            event.respondWith(networkWithCacheFallback(request));
        }
    }
});

// è¨Šæ¯äº‹ä»¶ - è™•ç†ä¾†è‡ªä¸»åŸ·è¡Œç·’çš„è¨Šæ¯
self.addEventListener('message', (event) => {
    const { type, payload } = event.data;
    
    switch (type) {
        case 'SKIP_WAITING':
            self.skipWaiting();
            break;
            
        case 'CLEAR_CACHE':
            clearAllCaches()
                .then(() => {
                    event.ports[0].postMessage({ success: true });
                })
                .catch((error) => {
                    event.ports[0].postMessage({ success: false, error: error.message });
                });
            break;
            
        case 'GET_CACHE_STATUS':
            getCacheStatus()
                .then((status) => {
                    event.ports[0].postMessage(status);
                })
                .catch((error) => {
                    event.ports[0].postMessage({ error: error.message });
                });
            break;
    }
});

// å¿«å–ç­–ç•¥å¯¦ç¾

// å¿«å–å„ªå…ˆç­–ç•¥
async function cacheFirst(request) {
    try {
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }
        
        const networkResponse = await fetch(request);
        if (networkResponse.status === 200) {
            const cache = await caches.open(STATIC_CACHE);
            cache.put(request, networkResponse.clone());
        }
        
        return networkResponse;
    } catch (error) {
        console.error('[SW] å¿«å–å„ªå…ˆç­–ç•¥å¤±æ•—:', error);
        return new Response('é›¢ç·šæ¨¡å¼ - è³‡æºä¸å¯ç”¨', { status: 503 });
    }
}

// ç¶²è·¯å„ªå…ˆç­–ç•¥
async function networkFirst(request) {
    try {
        const networkResponse = await fetch(request);
        
        if (networkResponse.status === 200) {
            const cache = await caches.open(DYNAMIC_CACHE);
            cache.put(request, networkResponse.clone());
        }
        
        return networkResponse;
    } catch (error) {
        console.log('[SW] ç¶²è·¯è«‹æ±‚å¤±æ•—ï¼Œå˜—è©¦å¿«å–:', request.url);
        
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }
        
        // å¦‚æœæ˜¯ API è«‹æ±‚ä¸”æ²’æœ‰å¿«å–ï¼Œè¿”å›é›¢ç·šå›æ‡‰
        if (isApiRequest(new URL(request.url))) {
            return new Response(JSON.stringify({
                error: 'ç›®å‰é›¢ç·šï¼Œè«‹ç¨å¾Œå†è©¦',
                offline: true
            }), {
                status: 503,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        return new Response('é›¢ç·šæ¨¡å¼ - è³‡æºä¸å¯ç”¨', { status: 503 });
    }
}

// ç¶²è·¯å›é€€åˆ°å¿«å–ç­–ç•¥
async function networkWithCacheFallback(request) {
    try {
        const networkResponse = await fetch(request);
        
        if (networkResponse.status === 200) {
            const cache = await caches.open(DYNAMIC_CACHE);
            cache.put(request, networkResponse.clone());
        }
        
        return networkResponse;
    } catch (error) {
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }
        
        // è¿”å›é›¢ç·šé é¢æˆ–åŸºæœ¬å›æ‡‰
        return new Response(`
            <!DOCTYPE html>
            <html lang="zh-Hant">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>é›¢ç·šæ¨¡å¼</title>
                <style>
                    body { 
                        font-family: sans-serif; 
                        text-align: center; 
                        padding: 50px; 
                        background: #2d2d3a; 
                        color: #e8e8e8; 
                    }
                    .offline-message {
                        max-width: 400px;
                        margin: 0 auto;
                        padding: 30px;
                        border-radius: 10px;
                        background: #3a3a4a;
                    }
                </style>
            </head>
            <body>
                <div class="offline-message">
                    <h1>ğŸ”Œ ç›®å‰é›¢ç·š</h1>
                    <p>è«‹æª¢æŸ¥æ‚¨çš„ç¶²è·¯é€£ç·šï¼Œç„¶å¾Œé‡æ–°æ•´ç†é é¢ã€‚</p>
                    <button onclick="location.reload()">é‡æ–°æ•´ç†</button>
                </div>
            </body>
            </html>
        `, {
            status: 503,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
        });
    }
}

// å·¥å…·å‡½æ•¸

function shouldExcludeUrl(url) {
    return EXCLUDED_URLS.some(pattern => pattern.test(url.href));
}

function isStaticAsset(url) {
    return url.pathname.match(/\.(css|js|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot|ico)$/);
}

function isApiRequest(url) {
    return url.pathname.startsWith('/api/') || 
           url.pathname.startsWith('/chat/') ||
           url.pathname.includes('ajax');
}

async function clearAllCaches() {
    const cacheNames = await caches.keys();
    const deletePromises = cacheNames.map(cacheName => caches.delete(cacheName));
    return Promise.all(deletePromises);
}

async function getCacheStatus() {
    const cacheNames = await caches.keys();
    const cacheStatus = {};
    
    for (const cacheName of cacheNames) {
        const cache = await caches.open(cacheName);
        const keys = await cache.keys();
        cacheStatus[cacheName] = keys.length;
    }
    
    return {
        caches: cacheStatus,
        totalCaches: cacheNames.length,
        timestamp: new Date().toISOString()
    };
}

// æ¨é€é€šçŸ¥æ”¯æ´ (æœªä¾†æ“´å±•)
self.addEventListener('push', (event) => {
    if (event.data) {
        const data = event.data.json();
        
        const options = {
            body: data.body,
            icon: '/static/images/pwa-192x192.png',
            badge: '/static/images/pwa-192x192.png',
            vibrate: [100, 50, 100],
            data: data.data || {},
            actions: data.actions || []
        };
        
        event.waitUntil(
            self.registration.showNotification(data.title, options)
        );
    }
});

// é€šçŸ¥é»æ“Šè™•ç†
self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    
    if (event.action) {
        // è™•ç†å‹•ä½œæŒ‰éˆ•é»æ“Š
        console.log('[SW] é€šçŸ¥å‹•ä½œ:', event.action);
    } else {
        // è™•ç†é€šçŸ¥æœ¬é«”é»æ“Š
        event.waitUntil(
            clients.openWindow('/')
        );
    }
});

console.log('[SW] Service Worker å·²è¼‰å…¥');